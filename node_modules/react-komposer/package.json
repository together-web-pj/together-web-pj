{
  "_args": [
    [
      {
        "raw": "react-komposer@^2.0.0",
        "scope": null,
        "escapedName": "react-komposer",
        "name": "react-komposer",
        "rawSpec": "^2.0.0",
        "spec": ">=2.0.0 <3.0.0",
        "type": "range"
      },
      "/home/user/work/version/reaction"
    ]
  ],
  "_from": "react-komposer@>=2.0.0 <3.0.0",
  "_id": "react-komposer@2.0.0",
  "_inCache": true,
  "_location": "/react-komposer",
  "_nodeVersion": "6.6.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/react-komposer-2.0.0.tgz_1478574942214_0.6227184745948762"
  },
  "_npmUser": {
    "name": "arunoda",
    "email": "arunoda.susiripala@gmail.com"
  },
  "_npmVersion": "4.0.0",
  "_phantomChildren": {
    "lodash.keys": "3.1.2"
  },
  "_requested": {
    "raw": "react-komposer@^2.0.0",
    "scope": null,
    "escapedName": "react-komposer",
    "name": "react-komposer",
    "rawSpec": "^2.0.0",
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-komposer/-/react-komposer-2.0.0.tgz",
  "_shasum": "b964738014a9b4aee494a83c0b5b833d66072a90",
  "_shrinkwrap": null,
  "_spec": "react-komposer@^2.0.0",
  "_where": "/home/user/work/version/reaction",
  "bugs": {
    "url": "https://github.com/kadirahq/react-komposer/issues"
  },
  "dependencies": {
    "babel-runtime": "^6.11.6",
    "hoist-non-react-statics": "^1.2.0",
    "lodash.pick": "^4.4.0",
    "react-stubber": "^1.0.0",
    "shallowequal": "^0.2.2"
  },
  "description": "Generic way to compose data containers for React.",
  "devDependencies": {
    "babel-cli": "^6.14.0",
    "babel-core": "^6.14.0",
    "babel-eslint": "^6.1.2",
    "babel-plugin-transform-runtime": "^6.15.0",
    "babel-polyfill": "^6.13.0",
    "babel-preset-react-app": "^0.2.1",
    "chai": "^3.5.0",
    "enzyme": "^2.2.0",
    "eslint": "^3.6.0",
    "eslint-config-airbnb": "^12.0.0",
    "eslint-plugin-import": "^1.16.0",
    "eslint-plugin-jsx-a11y": "^2.2.2",
    "eslint-plugin-react": "^6.3.0",
    "jsdom": "^9.5.0",
    "mocha": "^3.0.2",
    "react": "^15.3.2",
    "react-addons-test-utils": "^15.3.2",
    "react-dom": "^15.3.2",
    "sinon": "^1.17.6"
  },
  "directories": {},
  "dist": {
    "shasum": "b964738014a9b4aee494a83c0b5b833d66072a90",
    "tarball": "https://registry.npmjs.org/react-komposer/-/react-komposer-2.0.0.tgz"
  },
  "engines": {
    "npm": "^3.0.0"
  },
  "gitHead": "431012dd6edb102bc3a95d5107723ea7ece213e4",
  "homepage": "https://github.com/kadirahq/react-komposer#readme",
  "license": "MIT",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "arunoda",
      "email": "arunoda.susiripala@gmail.com"
    }
  ],
  "name": "react-komposer",
  "optionalDependencies": {},
  "peerDependencies": {
    "react": "^0.14.7 || ^15.0.0"
  },
  "readme": "# React Komposer\n\nFeed data into React components by composing containers. <br/>\n(Works with any kind of data store whether it's Redux, Promises, RxJX, MobX or anything else)\n\n## TOC\n<!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:0 orderedList:0 -->\n\n- [Why?](#why)\n- [Installation](#installation)\n- [Simple Example](#simple-example)\n- [Other Core Functionalities](#other-core-functionalities)\n\t- [Subscribing to data](#subscribing-to-data)\n\t- [Show Loading screen](#show-loading-screen)\n\t- [Handling errors](#handling-errors)\n- [Performance](#performance)\n- [Set Defaults](#set-defaults)\n- [Passing an Environment (Like Dependency Injection)](#passing-an-environment-like-dependency-injection)\n- [Server Side Rendering (SSR)](#server-side-rendering-ssr)\n- [Accessing the UI Component (via refs)](#accessing-the-ui-component-via-refs)\n- [Merging Multiple Containers](#merging-multiple-containers)\n- [Stubbing](#stubbing)\n- [Migrating from 1.x](#migrating-from-1x)\n\n<!-- /TOC -->\n\n## Why?\n\nIn React, usually we build UI components and feed data into them via containers. Let's call them data containers.\nInside that data containers, we may need to:\n\n* access different data sources\n* show loading screens\n* handle errors\n* subscribe to data and clean-up subscripts as needed\n* re-fetch data when props changed\n\nAmong a lot of other things.\nReact Komposer helps you create such data containers and you only need to worry about writing the data fetching(or integration) logic.\n\n## Installation\n\n```sh\nnpm install --save react-komposer@2.0.0-beta-4\n```\n\n## Simple Example\n\nLet's assume we've got a UI component called Blog Post like this:\n\n```js\nconst BlogPost = ({ post }) => (\n    <div>\n        <h2>{post.title}</h2>\n        <p>{post.content}</p>\n    </div>\n);\n```\n\nNow we need to fetch data from the server. So, we'll create a dataLoader like this:\n\n```js\nfunction postDataLoader(props, onData) {\n    // load data from the server. (using props.id to identify the post)\n    // (Here'll we'll use setTimeout for demonstration purpose)\n    setTimeout(function() {\n        const post = {\n            id: props.id,\n            title: 'Hello React Komposer',\n            content: 'This will help you to load data into your components.',\n        };\n        const data = { post };\n\n        // send the data as props to the BlogPost component.\n        // So, BlogPost will see the post object as a prop.\n        onData(null, data)\n    }, 1000);\n}\n```\n\nThen let's create the container:\n\n```js\nimport { compose } from 'react-komposer';\nconst BlogPostContainer = compose(postDataLoader)(BlogPost);\n```\n\nNow we could render the BlogPostContainer like this:\n\n```js\nimport ReactDOM from 'react-dom';\nReactDOM.render(<BlogPostContainer id='post-one' />, document.body);\n```\n\n[**Play with this example.**](http://www.webpackbin.com/4J6Z-fDlf)\n\n## Other Core Functionalities\n\nNow we know how to load data to a component using React Komposer. Let's have a look at our other core functionalities.\n\n### Subscribing to data\n\nUsually, we need to subscribe to a data source and update the UI as we get new changes. This is a part of the realtime UI's. With React Komposer, you could easily connect those subscriptions with UI components.\n\nFor the above BlogPost component, we can write a data loader like this:\n\n```js\nfunction postDataLoader(props, onData) {\n    // Create a subscription to the data server.\n    // Use props.id to identify the post.\n    // (Here'll we'll use setInterval for demonstration purpose)\n\n    const handler = setInterval(function() {\n        const post = {\n            id: props.id,\n            title: 'Hello React Komposer',\n            content: `\n              This will help you to load data into your components.\n              - Updated at: ${new Date().toLocaleString()}\n            `\n        };\n        const data = { post };\n\n        // send the data as BlogPost component.\n        // So, BlogPost will see the post object as a prop.\n        onData(null, data)\n    }, 1000);\n\n    // return a function which cleanup the handler\n    return () => { clearInterval(handler) }\n}\n```\n\nHere we are calling the **onData** callback for every one second.  We've also returned a function from where it'll be used to clear the resources allocated by the subscription when the container unmounted.\n\n[**Play with this example.**](http://www.webpackbin.com/Vk2AEfPez)\n\n### Show Loading screen\n\nIt'll take a bit of time to load data from the server. So, we usually show a loading screen.\nReact storybook will take care of that automatically.\n\nFor any data loader, we could get this by providing a loadingHandler like this:\n\n```js\nconst options = {\n  loadingHandler: () => (<p>Loading...</p>)\n};\nconst BlogPostContainer = compose(postDataLoader, options)(BlogPost);\n```\n\n**[Play with this example.](http://www.webpackbin.com/Vk_5lQ_xG)**\n\nWe show the loading screen until you provide a data object to the onData function. Have a look at the following data loader:\n\n```js\nfunction postDataLoader(props, onData) {\n\n}\n```\n\nSince we've not invoked the onData callback, there'll be the loading screen forever.\n\n### Handling errors\n\nUsually when we are dealing with remote data, we need to handle errors as well. React Komposer has its own way of handling errors. Check this example:\n\n```js\nfunction postDataLoader(props, onData) {\n   setTimeout(function() {\n     // Assume we got an error object\n     const error = new Error('Oops. Something is not right.');\n     // pass the error\n     onData(error);\n   }, 1000);\n}\n```\n\nBy default, we'll throw the error to the console. But you can provide a UI for error like this when creating the container:\n\n```js\nconst options = {\n  errorHandler: (err) => (\n    <p style={{color: 'red'}}>\n       {err.message}\n    </p>\n  )\n};\nconst BlogPostContainer = compose(postDataLoader, options)(BlogPost);\n```\n\n**[Play with this example.](http://www.webpackbin.com/Nk-4vmOgf)**\n\n## Performance\n\nPerformance is really important when building a real world apps. React Komposer comes with few ways to tune the performance. Let's discuss.\n\n### Props Watching\n\n> By default, we watch and re-run data loader for every prop change.\n\nIn the data loader, you can access props passed to your container like this:\n\n```js\nfunction postDataLoader(props, onData) {\n   console.log(props);\n}\n```\n\nWe re-run the dataLoader for every prop change in the container. If we are using a prop inside the data loader, it's required to re-run the dataLoader when the prop changes.\n\nBut reruns for any other prop change is not necessary.\n\nSo, we can ask React Komposer to only re-run when given props have changed. Have a look at the following code:\n\n```js\nconst options = {\n    propsToWatch: ['id']\n};\nconst BlogPostContainer = compose(postDataLoader, options)(BlogPost);\n```\n\nHere we only re-run the data loader only when the prop named `id` gets changed.\n\n### Should Resubscribe\n\n> By default, this is null.\n\nThis gives the same functionality as props watching, but with more control. With the **propsToWatch** option, we do a shallow comparison. If that doesn't work for you, you can use the **shouldSubscribe** option as shown below:\n\n```js\nconst options = {\n    shouldSubscribe(currentProps, nextProps) {\n        // return true if you need to re-run the data loader again.\n    }\n};\n```\n\n### Pure\n\n> By default, this is false.\n\n\nThis will take care of the component re-rendering for every prop change. You can make the container pure by applying the following option:\n\n```js\nconst options = {\n    pure: true,\n};\nconst BlogPostContainer = compose(postDataLoader, options)(BlogPost);\n```\n\nThen, this will add a [pure render mixin](https://facebook.github.io/react/docs/pure-render-mixin.html) to the React component. (This will compare props in shallow manner).\n\n### Should Update\n\n> By default, this is null\n\nThis will provide the same functionality as pure, but with more control. With pure, we compare props shallowly. But, you can use shouldUpdate option to compare it as you want.\n\nCheck the following example:\n\n```js\nconst options = {\n    shouldUpdate(currentProps, nextProps) {\n        // return true if you need to render the compare with nextProps.\n    },\n};\nconst BlogPostContainer = compose(postDataLoader, options)(BlogPost);\n```\n\n## Set Defaults\n\nUsually, you may want to use the same set of options for every container you create. So, you could set defaults like this:\n\n```js\nimport { setDefaults } from 'react-komposer';\n\nconst myCompose = setDefaults({\n    pure: true,\n    propsToWatch: [],\n    loadingHandler: () => (<p>Loading...</p>),\n});\n```\n\nThen you can use `myCompose` instead `compose` when creating containers.\n\n> It's pretty useful to setDefaults like this create a customized composer for your app.\n\n\nYou can override any of these options by providing options when creating the container.\n\n## Passing an Environment (Like Dependency Injection)\n\nThis is a pretty neat feature where you can use to inject dependencies.\n\nUsually, your UI component doesn't know about app specific information. But containers do know that. Using env option of React Komposer you could pass a env where your data loaders could utilize.\n\n\n> This is useful to use with a custom composer created with setDefaults\n\n\nHave a look at the following example:\n\n```js\nimport { setDefaults } from 'react-komposer';\n\n// This is the reduxStore of your app.\nconst reduxStore = {};\n\nconst myCompose = setDefaults({\n    //...otherOptions\n    env: {\n        reduxStore\n    }\n});\n```\n\nThen you can access the environment from any dataLoader when the container is created **myCompose**.\n\n```js\nfunction postDataLoader(props, onData, env) {\n   // access the redux container and subscribe to that\n   return env.reduxStore.subscribe((state) => {\n       onData(null, state);\n   });\n}\n```\n\n## Server Side Rendering (SSR)\n\nUsually data loaders run in the constructor of the React component. So, it'll run with SSR as well.\nBut it won't stop subscriptions for you.\n\nSo, you need to identify the SSR environment from your dataLoader, and do not subscribe for data inside that.\nHave a look at the following code base:\n\n```js\nfunction postDataLoader(props, onData, env) {\n   if (isSSR) {\n      const data = fetchData();\n      onData(null, data);\n      return;\n   }\n\n   const stopSubscription = watchData((data) => {\n      onData(null, data);\n   });\n   return stopSubscription;\n}\n```\n## Accessing the UI Component (via refs)\n\nSometimes ( although not recommended) you may want to access the underlining UI component instead of the container. Then you can call it the **child** property of container instance.\n\n## Merging Multiple Containers\n\nSometimes, you may want to use multiple data loaders for a single UI component. Then you will have to do something like this:\n\n```js\nconst Container1 = compose(dataLoader1)(UIComponent);\nconst Container2 = compose(dataLoader2)(Container1);\nconst Container3 = compose(dataLoader3)(Container2);\n\nexport default Container3;\n```\n\nWith our merge utility, you could do it like this:\n\n```js\nimport { merge } from 'react-komposer';\n\nexport default merge(\n    compose(dataLoader1),\n    compose(dataLoader2),\n    compose(dataLoader3),\n)(UIComponent);\n```\n\n## Stubbing\n\nSometimes, you may wanna use containers created with React Komposer in environments where it couldn't work. <br/>\n(For an example, React Storybook. It might not have your dataStores)\n\nFor those environments, you could stub your containers.\n\nFor that, simply put following lines before import any of your components.\n(In React Storybook, it should be the config.js file)\n\n```js\nimport { setStubbingMode } from 'react-stubber';\nsetStubbingMode(true);\n```\n\nThen you could stub your containers as you want. Follow the [react-stubber](https://github.com/kadirahq/react-stubber) documentation for more information.\n\n> Internally, React Komposer uses [react-stubber](https://github.com/kadirahq/react-stubber) to add stubbing support.\n\n## Migrating from 1.x\n\nReact Komposer 2.x is almost compatible with 1.x but with few minor changes. Here are they:\n\n### No default error and loading components\n\n1.x comes with default components for error and loading components. But, now you need to specify them manually with **errorHandler** and **loadingHandler** options.\n\nWe do this because, we want to use React Komposer on both React and React Native environment. Shipping defaults components make it harder to.\n\n### ComposeAll is now merge\n\n1.x has a function called composeAll which does exactly the same functionality as merge. Now we have renamed it as merge. But still, composeAll is available.\n\n### By Default pure=false\n\nEarlier, all of the containers we created were pure. But now you need to pass the pure option to make it pure.\n\n### No utility composers for promises, redux and etc.\n\nEarlier, we shipped a set of composers for different kinds of data stores. But now they are not shipped with this project. We recommend you create a data loader generator instead. Then use it.\n\n> You may also publish it into NPM and share it with others.\n\nHave a look at some example data loader generators:\n\n**For Promises**\n\n```js\nfunction genPromiseLoader(promise) {\n    return (props, onData) {\n      promise\n        .then((data) => onData(null, data))\n        .catch((err) => onData(err))\n    };\n}\n\n// usage\nconst Container = compose(genPromiseLoader(somePromiseObject))(UIComponent);\n```\n\n**For Redux**\n\n```js\nfunction getReduxLoader(mapper) {\n    return (props, onData, env) {\n        // Accessing the reduxStore via the env.\n        return env.reduxStore.subscribe((state) => {\n            onData(null, mapper(state));\n        });\n    };\n}\n\n// usage (expect you to pass the reduxStore via the env)\nconst myMapper = ({user}) => ({user});\nconst Container = compose(getReduxLoader(myMapper))(UIComponent)\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kadirahq/react-komposer.git"
  },
  "scripts": {
    "lint": "eslint src",
    "lintfix": "eslint src --fix",
    "prepublish": ". ./.scripts/prepublish.sh",
    "publish-storybook": "bash .scripts/publish_storybook.sh",
    "storybook": "start-storybook -p 9010",
    "test": "npm run lint && npm run testonly",
    "test-watch": "npm run testonly -- --watch --watch-extensions js",
    "testonly": "mocha --require .scripts/mocha_runner src/**/tests/**/*.js"
  },
  "version": "2.0.0",
  "warnings": [
    {
      "code": "ENOTSUP",
      "required": {
        "npm": "^3.0.0"
      },
      "pkgid": "react-komposer@2.0.0"
    }
  ]
}
